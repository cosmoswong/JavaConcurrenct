## 该部分的讲解内容：
高并发编程第一阶段01讲、课程大纲及主要内容介绍

高并发编程第一阶段02讲、简单介绍什么是线程

高并发编程第一阶段03讲、创建并启动线程

高并发编程第一阶段04讲、线程生命周期以及start方法源码剖析

高并发编程第一阶段05讲、采用多线程方式模拟银行排队叫号

高并发编程第一阶段06讲、用Runnable接口将线程的逻辑执行单元从控制中抽取出来

高并发编程第一阶段07讲、策略模式在Thread和Runnable中的应用分析

高并发编程第一阶段08讲、构造Thread对象你也许不知道的几件事

高并发编程第一阶段09讲、多线程与JVM内存结构的关系，虚拟机栈实验

高并发编程第一阶段10讲、Thread构造函数StackSize详细讲解

高并发编程第一阶段11讲、Thread构造函数StackSize详细讲解-续

高并发编程第一阶段12讲、Daemon线程的创建以及使用场景分析

高并发编程第一阶段13讲、线程ID，优先级讲解

高并发编程第一阶段14讲、Thread的join方法详细介绍，结合一个典型案例

高并发编程第一阶段15讲、Thread中断Interrupt方法详细讲解

高并发编程第一阶段16讲、采用优雅的方式结束线程生命周期

高并发编程第一阶段17讲、Thread API综合实战，编写ThreadService实现暴力结束线程的综合实战

高并发编程第一阶段18讲、数据同步的引入与Synchronized的简单介绍

高并发编程第一阶段19讲、结合jconsole,jstack以及汇编指令认识synchronized关键字

高并发编程第一阶段20讲、同步代码块以及同步方法之间的区别和关系

高并发编程第一阶段21讲、通过实验分析This锁的存在

高并发编程第一阶段22讲、通过实验分析Class锁的存在

高并发编程第一阶段23讲、多线程死锁分析，案例介绍

高并发编程第一阶段24讲、线程间通信快速入门，使用wait和notify进行线程间的数据通信

高并发编程第一阶段25讲、多Produce多Consume之间的通讯导致出现程序假死的原因分析

高并发编程第一阶段26讲、多线程下的生产者消费者模型，以及详细介绍notifyAll方法

高并发编程第一阶段27讲、wait和sleep的本质区别是什么，深入分析（面试常见问题）

高并发编程第一阶段28讲、线程生产者消费者的综合实战结合Java8语法

高并发编程第一阶段29讲、如何实现一个自己的显式锁Lock精讲上

高并发编程第一阶段30讲、如何实现一个自己的显式锁Lock精讲下（让锁具备超时功能）

高并发编程第一阶段31讲、如何给你的应用程序注入钩子程序，Linux下演示

高并发编程第一阶段32讲、如何捕获线程运行期间的异常

高并发编程第一阶段33讲、ThreadGroup API介绍之一

高并发编程第一阶段34讲、ThreadGroup API介绍之二

高并发编程第一阶段35讲、线程池原理与自定义线程池

高并发编程第一阶段36讲、自定义个简单的线程池并且测试

高并发编程第一阶段37讲、给线程池增加拒绝策略以及停止方法

高并发编程第一阶段38讲、给线程池增加自动扩充线程数量，以及闲时自动回收的功能

高并发编程第一阶段39讲、课程结束，内容回顾，下季内容预告